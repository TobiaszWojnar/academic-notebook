#!/usr/bin/env python3
from typing import List, Tuple, Iterable
from sys import argv, exit, stderr
from getopt import getopt
from bitwiseio import BitReader, BitWriter
import os


def one_bitpack(f: BitReader, size: int = 8) -> int:
    """Reads a series of `size` bits and returns it as an integer.
    Defaults to bitpack of size 8 bits (one byte).
    This function expects a `BitReader` that reads individual bits not bytes.
    """
    return f.readbits(size)


def bitpack_list(f: BitReader, count: int, size: int = 8) -> Tuple[int]:
    """Reads `count` bit packs and returns it as a tuple of integers.
    Defaults to bytes.
    This function expects a `BitReader` that reads individual bits not bytes.
    """
    return tuple(one_bitpack(f, size=size) for _ in range(count))


def int_from_bytes(bytes_) -> int:
    """Calculates an integer from provided bytes.
    """
    output = 0
    for i in range(0, len(bytes_)):
        output += bytes_[i] * (2**(8*i))
    return output


def add_pixels_mod(one: Tuple[int], two: Tuple[int], mod: int):
    """Adds two pixels' values together and keeps them in range of [0,255].
    """
    return tuple(
        (one[i] + two[i]) % mod for i in range(0, 3)
    )


def encode(input_image: str, output_file: str, bitdepth: int) -> None:
    """Encodes given image to a propriatory format file with a specialized
    header on top of the original file's TGA header.
    """

    with open(input_image, 'rb+') as fi:
        with BitReader(fi) as reader:
            # read the the first part of the original header
            header_header = bitpack_list(reader, 12)
            image_width_raw = bitpack_list(reader, 2)
            image_width = int_from_bytes(image_width_raw)
            image_height_raw = bitpack_list(reader, 2)
            image_height = int_from_bytes(image_height_raw)
            # read the rest of the header
            header_the_rest = bitpack_list(reader, 2)

            with open(output_file, "wb+") as fo:
                with BitWriter(fo) as writer:
                    # copy the original header over
                    writer.writebits(int_from_bytes(
                        bytes(header_header[::-1])), 12 * 8)
                    writer.writebits(int_from_bytes(
                        bytes(image_width_raw[::-1])), 2 * 8)
                    writer.writebits(int_from_bytes(
                        bytes(image_height_raw[::-1])), 2 * 8)
                    writer.writebits(int_from_bytes(
                        bytes(header_the_rest[::-1])), 2 * 8)

                    # write a propriatory header that contains the bitdepth
                    writer.writebits(bitdepth, 8)

                    # start encoding from \vec0
                    previous_pixel = (0, 0, 0)

                    for _ in range(image_width * image_height):
                        current_pixel = bitpack_list(reader, 3)
                        # iterate over all colours
                        quantized_difference = [0 for _ in range(3)]
                        for c in range(0, 3):
                            quantized_difference[c] = \
                                (current_pixel[c] - previous_pixel[c])\
                                % 256\
                                >> (8-bitdepth)
                            writer.writebits(quantized_difference[c], bitdepth)
                            quantized_difference[c] = quantized_difference[c] << (8-bitdepth)
                        # replace the old pixel with the current one
                        previous_pixel = add_pixels_mod(
                            previous_pixel, quantized_difference, 256)

                    # copy the original footer over
                    while reader.read:
                        x = reader.readbits(8)
                        writer.writebits(x, 8)


def decode(input_file: str, output_image: str) -> None:
    """Decodes given binary file back to the original TGA image.
    Input file needs to be a binary file generated by `encode` function.
    """

    with open(input_file, 'rb+') as fi:
        with BitReader(fi) as reader:
            # read the the first part of the original header
            header_header = bitpack_list(reader, 12)
            image_width_raw = bitpack_list(reader, 2)
            image_width = int_from_bytes(image_width_raw)
            image_height_raw = bitpack_list(reader, 2)
            image_height = int_from_bytes(image_height_raw)
            # read the rest of the header
            header_the_rest = bitpack_list(reader, 2)

            # read the propriatory header
            bitdepth = one_bitpack(reader)

            with open(output_file, "wb+") as fo:
                with BitWriter(fo) as writer:

                    # copy the original header over
                    writer.writebits(int_from_bytes(
                        bytes(header_header[::-1])), 12 * 8)
                    writer.writebits(int_from_bytes(
                        bytes(image_width_raw[::-1])), 2 * 8)
                    writer.writebits(int_from_bytes(
                        bytes(image_height_raw[::-1])), 2 * 8)
                    writer.writebits(int_from_bytes(
                        bytes(header_the_rest[::-1])), 2 * 8)

                    # start from a \vec0
                    previous_pixel = (0, 0, 0)

                    for _ in range(image_height * image_width):
                        # read the offset
                        current_offset = tuple(map(
                            lambda x: x << (8-bitdepth),
                            bitpack_list(reader, 3, size=bitdepth)
                        ))
                        # recreate a quantized pixel
                        previous_pixel = add_pixels_mod(
                            previous_pixel, current_offset, 256)
                        # save recovered pixel
                        for c in range(0, 3):
                            t = previous_pixel[c]
                            writer.writebits(t, 8)

                    # recover the original file footer
                    while reader.read:
                        x = reader.readbits(8)
                        writer.writebits(x, 8)


if __name__ == "__main__":

    raw_args = argv[1:]
    optlist, args = getopt(raw_args, '', ['mode='])

    usage_help = 'usage: ./main.py --mode <encode|decode> <input file> <output file> [bit depth]'

    if len(args) < 2 and len(optlist) < 1:
        exit(usage_help)

    input_file = args[0]
    output_file = args[1]
    bitdepth = None
    if len(args) >= 3:
        bitdepth = int(args[2])

    mode = None
    for opt, arg in optlist:
        if opt == '--mode':
            if arg == 'encode' and bitdepth is None:
                print('encode mode requires bit depth option')
            elif arg == 'encode':
                mode = 'e'
            elif arg == 'decode':
                mode = 'd'
            else:
                print('invalid --mode')
                exit(usage_help)

    if mode == 'e':
        encode(input_file, output_file, bitdepth)
    else:  # mode == 'd'
        decode(input_file, output_file)
